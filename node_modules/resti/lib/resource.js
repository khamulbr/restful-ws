import * as utils from './utils.js';

/**
 * Cache globally set request headers to be set on all requests.
 * Bool to determine whether to set RequestedWith header.
 * Bool to determine whether to use trailing slashes when building URLS.
 * Default headers for all requests. Overwritten by globalheaders then resource specific headers.
 */
let globalHeaders = {};
let globalReqWithHeader = true;
let globalUseTrailingSlashes = false;
const defaultHeaders = {
	'Content-Type': utils.types['json'],
	'Accept': utils.types['json']
};

/**
 * Initialise a new Resource object.
 *
 * @param {String} url
 * @param {Number} id
 * @return {Resource}
 * @api public
 */

class Resource {

	constructor(url, id) {
		if (!url) utils.throwError('resti must be passed a base URL');
		this.url = null;
		this.data = {};
		this.headers = utils.extend({}, defaultHeaders, globalHeaders);
		this.parameters = {};
		this.parser = null;
		this.beforeStack = [];
		this.stack = [];
		this.setURL(url, id);
		this._reqWithHeader = !!globalReqWithHeader;
		this._trailingSlashes = !!globalUseTrailingSlashes;
		return this;
	}

	/**
	 * Set global headers on all Resource requests.
	 * Will be overridden if same header is set on an instance.
	 *
	 * @param {String} header
	 * @param {String} value
	 * @api public
	 */
	static header(header, value) {
		if (utils.isObject(header)) {
			utils.forIn(header, function(_header, _value) {
				Resource.header(_header, _value);
			});
		} else {
			globalHeaders[header] = (utils.types[value] || value);
		}
	}

	/**
	 * Set global boolean to determine if X-Requested-With header 
	 * is to be set to XMLHttpRequest or not, for all requests.
	 * Overridden by instance based setting.
	 * Default is true.
	 *
	 * @api public
	 */
	static enableReqWithHeader() {
		globalReqWithHeader = true;
	}

	/**
	 * Set global boolean to determine if X-Requested-With header 
	 * is to be set to XMLHttpRequest or not, for all requests.
	 * Overridden by instance based setting.
	 * Default is true.
	 *
	 * @api public
	 */
	static disableReqWithHeader() {
		globalReqWithHeader = false;
	}

	/**
	 * Reset global cached variables.
	 *
	 * @param {Function}
	 * @api public
	 */
	static reset() {
		globalHeaders = {};
		globalReqWithHeader = true;
		globalUseTrailingSlashes = false;
	}

	/**
	 * Enable global trailing slashes global setting.
	 *
	 * @api public
	 */
	static enableTrailingSlashes() {
		globalUseTrailingSlashes = true;
	}

	/**
	 * Disable global trailing slashes global setting.
	 *
	 * @api public
	 */
	static disableTrailingSlashes() {
		globalUseTrailingSlashes = true;
	}

	/**
	 * Set URL for the next request based on various factors.
	 *
	 * @return {Resource}
	 * @api private
	 */
	setURL(url, id) {
		this.url = url;
		if (id) {
			this.url = utils.buildURL(this.url, id, !!globalUseTrailingSlashes);
		}
		return this;
	}

	/**
	 * Clone this resource with already set headers and middleware.
	 * and provided parameters.
	 *
	 * @param {String|Number} url
	 * @param {String|Number} id
	 * @return {Resource}
	 * @api private
	 */
	clone(url, id) {
		const resource = new Resource(url, id);
		resource.headers = utils.extend({}, this.headers);
		resource.stack = this.stack.slice(0);
		resource.beforeStack = this.beforeStack.slice(0);
		resource.parser = this.parser;
		return resource; 
	}

	/**
	 * Create a new resource based on this resources base URL 
	 * and provided parameters.
	 *
	 * @param {String|Number} url
	 * @param {String|Number} id
	 * @return {Resource}
	 * @api public
	 */
	one(url, id) {
		if (!url) return this.clone(this.url);
		if (utils.isAbsoluteUrl(url)) return this.clone(url, id);
		const newUrl = utils.buildURL(this.url, url, !!this._trailingSlashes);
		return this.clone(newUrl, id);
	}

	/**
	 * Create a new resource based on this resources base URL 
	 * and provided parameters.
	 *
	 * @param {String|Number} identifier
	 * @return {Resource}
	 * @api public
	 */
	many(url) {
		if (!url) return this.clone(this.url);
		if (utils.isAbsoluteUrl(url)) return this.clone(url);
		const newUrl = utils.buildURL(this.url, url, !!this._trailingSlashes);
		return this.clone(newUrl);;
	}

	/**
	 * Create a new resource based on this resources base URL 
	 * and provided parameters. For creating endpoints that don't 
	 * correspond to resources.
	 *
	 * @param {String|Number} url
	 * @return {Resource}
	 * @api public
	 */
	endpoint(url) {
		if (!url) return this.clone(this.url);
		if (utils.isAbsoluteUrl(url)) return this.clone(url);
		const newUrl = utils.buildURL(this.url, url, !!this._trailingSlashes);
		return this.clone(newUrl);
	}

	/**
	 * Set/get header/s for next request.
	 *
	 * @param {String|Object} header|header:value pairs
	 * @param {String|Boolean} value
	 * @return {Resource}
	 * @api public
	 */
	header(header, value) {
		if (utils.isObject(header)) {
			utils.forIn(header, function(property, _value) {
				this.header(property, _value);
			}, this);
		} else {
			if (arguments.length == 1) {
				return this.headers[header] ? this.headers[header] : false;
			} else {
				if (value === false) {
					delete this.headers[header];
				} else {
					this.headers[header] = (utils.types[value] || value);
				}
			}
		}
		return this;
	}

	/**
	 * Determine if a specific header is set for current request cycle.
	 * Pass value to determine if header is also set to value.
	 *
	 * @param {String|Object} header|header:value pairs
	 * @param {String} value
	 * @return {Boolean}
	 * @api public
	 */
	using(header, value) {
		if (header && !value) {
			if (utils.isObject(header)) {
				let usingAll = true;
				utils.forIn(header, (prop, val) => {
					usingAll = !!this.headers[prop] && this.headers[prop] == (utils.types[val] || val);
				});
				return usingAll;
			} else {
				return !!this.headers[header];
			}
		} else if (header && value) {
			return !!this.headers[header] && this.headers[header] == (utils.types[value] || value);
		}
		return false;
	}

	/**
	 * Set or get Content-Type header for next request.
	 *
	 * @param {String} Content Type
	 * @return {Resource|Boolean}
	 * @api public
	 */
	type(type) {
		if (!arguments.length) {
			return this.header('Content-Type');
		}
		this.header('Content-Type', utils.types[type] || type);
		return this;
	}

	/**
	 * Set Accept header for next request.
	 *
	 * @param {String} Content Type
	 * @return {Resource}
	 * @api public
	 */
	accept(type) {
		if (!arguments.length) {
			return this.header('Accept');
		}
		this.header('Accept', utils.types[type] || type);
		return this;
	}

	/**
	 * Set boolean to determine if X-Requested-With header 
	 * is set to XMLHttpRequest on current request cycle or not.
	 *
	 * @param {Boolean}
	 * @return {Resource}
	 * @api public
	 */
	enableReqWithHeader() {
		this._reqWithHeader = true;
		return this;
	}

	/**
	 * Set boolean to determine if X-Requested-With header 
	 * is set to XMLHttpRequest on current request cycle or not.
	 *
	 * @param {Boolean}
	 * @return {Resource}
	 * @api public
	 */
	disableReqWithHeader() {
		this._reqWithHeader = false;
		return this;
	}

	/**
	 * Set global boolean to determine if X-Requested-With header 
	 * is to be set to XMLHttpRequest or not, for all requests.
	 * Overridden by instance based setting.
	 * Default is true.
	 *
	 * @api public
	 */
	enableTrailingSlashes() {
		this._trailingSlashes = true;
		return this;
	}

	/**
	 * Set global boolean to determine if X-Requested-With header 
	 * is to be set to XMLHttpRequest or not, for all requests.
	 * Overridden by instance based setting.
	 * Default is true.
	 *
	 * @api public
	 */
	disableTrailingSlashes() {
		this._trailingSlashes = false;
		return this;
	}

	/**
	 * Pass params to be set on the current url.
	 *
	 * @param {String|Object} property
	 * @param {String} value
	 * @return {Resource}
	 * @api public
	 */
	params(property, value) {
		if (utils.isObject(property)) {
			utils.forIn(property, function(_property, _value) {
				this.params(_property, _value);
			}, this);
		} else {
			this.parameters[property] = value;
		}
		return this;
	}

	/**
	 * Add a function to be used to parse the response to
	 * the next request.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	parse(fn) {
		this.parser = fn;
		return this;
	}

	/**
	 * Add before middleware.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	before(method, handle) {
		if (utils.isFunction(method)) {
			handle = method;
			method = null;
		}
		this.beforeStack.push({ method, handle })
		return this;
	}

	/**
	 * Add middleware.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	use(method, handle) {
		if (utils.isFunction(method)) {
			handle = method;
			method = null;
		}
		this.stack.push({ method, handle })
		return this;
	}

	/**
	 * Reset properties on an instance to prepare it for a new
	 * request cycle.
	 *
	 * @return {Resource}
	 * @api private
	 */
	reset() {
		this.headers = {};
		this.parameters = {};
		this.beforeStack = [];
		this._trailingSlashes = !!globalUseTrailingSlashes;
		this.stack = [];
		this.data = {};
		return this;
	}

	/**
	 * Attach data to be sent as payload with the next request.
	 *
	 * @param {Object|String} data
	 * @return {Resource}
	 * @api public
	 */
	send(property, value) {
		
		if (utils.isObject(property) && utils.isObject(this.data)) {
			this.data = utils.extend(this.data, property);
		} else 

		if (utils.isString(property)) {
			if (value) {
				this.data[property] = value;
			} else {
				const pairs = property.split('&');
				for (var i = 0, l = pairs.length; i < l; i++) {
					let pair = pairs[i];
					pair = pair.split('=');
					this.data[pair[0]] = pair[1];
				}
			}
		} else {
			this.data = property;
		}
		return this;
	}

	/**
	 * Helper to determine if currently set URL contains str.
	 * 
	 * @param {String} str
	 * @return {Boolean}
	 * @api public
	 */
	urlContains(str) {
		return utils.stringContains(this.url, str);
	}

	/**
	 * Make and start the middleware call stack for a specific stage of the req/res cycle
	 *
	 * @param {String} Stack of middleware.
	 * @param {Function} Method type used by resource.
	 * @param {Function} Resource or response to be used as the callback param for middleware.
	 * @api private
	 */
	startMiddleware(stack, method, parameter) {
		let index = 0;

		function next() {
			const layer = stack[index++];
			
			// end of stack
			if (!layer) return;

			if (layer.method) {
				if (method != layer.method) {
					return next();
				}
			}

			utils.callMiddleware(layer.handle, parameter, next);
		}

		next();
	}

	/**
	 * Abort request before it is finished
	 *
	 * @return {Resource}
	 * @api public
	 */
	abort() {
		this.xhr && this.xhr.abort();
		this.aborted = true;
		return this;
	}

	/**
	 * Send GET request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	get(fn) {
		var method = 'GET';
		this.end(method, fn);
		return this;
	}

	/**
	 * Send POST request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	post(fn) {
		var method = 'POST';
		this.end(method, fn);
		return this;
	}

	/**
	 * Send PUT request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	put(fn) {
		var method = 'PUT';
		this.end(method, fn);
		return this;
	}

	/**
	 * Send PATCH request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	patch(fn) {
		var method = 'PATCH';
		this.end(method, fn);
		return this;
	}

	/**
	 * Send HEAD request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	head(fn) {
		var method = 'HEAD';
		this.end(method, fn);
		return this;
	}

	/**
	 * Send DELETE request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	remove(fn) {
		var method = 'DELETE';
		this.end(method, fn);
		return this;
	}

	/**
	 * Send OPTIONS request with current instance, passing
	 * callback to be called after request finished.
	 *
	 * @param {Function} fn
	 * @return {Resource}
	 * @api public
	 */
	options(fn) {
		var method = 'OPTIONS';
		this.end(method, fn);
		return this;
	}

	/**
	 * End the current request cycle and send the XMLHttpRequest
	 * object with specified options, data and parameters.
	 * Fn gets called on completion of request.
	 *
	 * @param {String} method
	 * @param {Function} fn
	 * @return {Resource}
	 * @api private
	 */
	end(method, fn) {
		delete this.aborted;
		const self = this;
		const stack = this.stack.slice(0);
		const xhr = this.xhr = utils.getXHR();
		const params = this.parameters;
		const type = this.type();
		this.method = method.toLowerCase();

		let url = utils.objectSize(params) ? utils.setParams(this.url, params) : this.url;
		const serializer = utils.serializers[type];

		// set X-Requested-With depending on global and instance based settings
		if (this._reqWithHeader === true || (this._reqWithHeader !== false && globalReqWithHeader === true)) {
			this.header('X-Requested-With', 'XMLHttpRequest');
		}

		xhr.onreadystatechange = function() {
			if (4 !== this.readyState) return;
			
			if (!self.aborted) {
				const res = new Resource.Response(self.method, xhr, self);
				
				if (fn && utils.isFunction(fn)) {
					stack.push({ handle: fn });
				}

				self.startMiddleware(stack, self.method, res);
			}

			delete self.xhr;
		};

		this.before(function() {
			let data = utils.objectSize(this.data) && utils.methodShouldHavePayload(this.method) ? this.data : null;
			if (serializer && data != null) data = serializer(data);
			if (type == utils.types['form'] && 'get' != this.method && 'head' != this.method) {
				url += '?' + data;
				data = null;
			}
			xhr.open(this.method.toUpperCase(), url, true);
			utils.setHeaders(xhr, this.headers);
			xhr.send(data);
		});

		if (this.aborted) return;
		const beforeStack = this.beforeStack.slice(0);
		this.startMiddleware(beforeStack, this.method, self);
		return this;
	}

}

export default Resource;